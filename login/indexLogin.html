// api/ai/check-account.js

async function readBody(req) {
  if (req.body && typeof req.body === 'object') return req.body;
  const chunks = []; for await (const c of req) chunks.push(c);
  try { return JSON.parse(Buffer.concat(chunks).toString('utf8') || '{}'); } catch { return {}; }
}
function send(res, code, obj){ return res.status(code).json(obj); }

async function fetchJSON(url, key) {
  const r = await fetch(url, { headers: { apikey: key, Authorization: `Bearer ${key}` } });
  const text = await r.text();
  let json; try { json = JSON.parse(text); } catch { json = null; }
  return { r, json, text };
}

function normalizeEmail(v) {
  return (v ?? '').toString().trim().replace(/\s+/g, '').toLowerCase();
}

function pullUsersFrom(json) {
  if (!json) return [];
  if (Array.isArray(json)) return json;
  if (Array.isArray(json.users)) return json.users;
  if (json.user) return [json.user];
  return [];
}

export default async function handler(req, res) {
  const t0 = Date.now();
  if (req.method !== 'POST') return send(res, 405, { error: 'Only POST allowed' });

  const base = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key  = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!base || !key) return send(res, 500, { error: 'Missing env vars' });

  try {
    const { email: rawEmail } = await readBody(req);
    const email = normalizeEmail(rawEmail);

    console.log('[check-account] raw:', rawEmail);
    console.log('[check-account] normalized:', email);

    if (!email || !email.includes('@')) {
      return send(res, 400, { error: 'email required', debug: { rawEmail, email } });
    }

    // 1) Direct lookup (with audience) â€” some projects need aud=authenticated
    const url1 = `${base}/auth/v1/admin/users?email=${encodeURIComponent(email)}&aud=authenticated`;
    const { r: r1, json: j1, text: text1 } = await fetchJSON(url1, key);
    const users1 = pullUsersFrom(j1);
    let exists = users1.some(u => (u?.email || '').toLowerCase() === email);

    console.log('[check-account] step1 status:', r1.status, r1.statusText);
    console.log('[check-account] step1 users_len:', users1.length);
    if (!exists) console.log('[check-account] step1 raw json:', text1);

    // 2) Fallback: page through users and match email server-side
    let pagesChecked = 0;
    if (!exists) {
      for (let page = 1; page <= 5; page++) {
        const urlPage = `${base}/auth/v1/admin/users?aud=authenticated&page=${page}&per_page=200`;
        const { r, json, text } = await fetchJSON(urlPage, key);
        const users = pullUsersFrom(json);
        pagesChecked = page;
        const hit = users.find(u => (u?.email || '').toLowerCase() === email);

        console.log(`[check-account] page ${page} status:`, r.status, r.statusText, 'users_len:', users.length);

        if (hit) { exists = true; break; }
        if (!Array.isArray(users) || users.length === 0) break; // reached end
        // Optionally log first page json for debugging:
        if (page === 1 && !exists) console.log('[check-account] page1 sample json:', text.slice(0, 500));
      }
    }

    console.log('[check-account] exists:', exists, 'pagesChecked:', pagesChecked, 'done in ms:', Date.now() - t0);

    return send(res, 200, {
      exists,
      debug: {
        emailRaw: rawEmail,
        emailNormalized: email,
        step1UsersLen: users1.length,
        pagesChecked
      }
    });
  } catch (e) {
    console.error('[check-account] fatal:', e);
    return send(res, 500, { error: e?.message || 'unknown error' });
  }
}
